---
description: Automated git commit workflow with conventional commits
globs:
alwaysApply: true
---

# Automated Commit Workflow Rules for YouTube VJ React Project

## Overview

This rule set defines an automated commit workflow that triggers when users indicate their intention to commit. The workflow includes staging verification, diff analysis, commit message generation, and commit execution.

**🚨 CRITICAL ENHANCEMENT**: This version includes strict cognitive bias prevention measures to ensure accurate diff analysis and commit message generation.

## Workflow Triggers

### User Intent Keywords

When users express commit intention using these phrases, the automated workflow should activate:

**Japanese Triggers:**

- "コミット"
- "コミットして"
- "コミットしたい"
- "コミットお願いします"
- "変更をコミット"
- "これをコミット"

**English Triggers:**

- "commit"
- "commit this"
- "commit changes"
- "make a commit"
- "please commit"
- "commit these changes"

## Automated Workflow Steps

### Step 1: Pre-Commit Validation

1. **Check git repository status**

   ```bash
   git status
   ```

2. **Verify staged changes exist**
   - If no changes staged: Ask user to specify files to stage
   - If changes staged: Proceed to Step 2

### Step 2: Staging Management

1. **NEVER auto-stage files (重要なルール)**

   - ❌ `git add .` や `git add <file>` を自動実行してはならない
   - ✅ 既にステージングされたファイルのみ処理する
   - ✅ ステージングされたファイルがない場合は、ユーザーに手動でのステージングを促す

2. **Handle unstaged changes**
   - If no staged changes: Display message asking user to stage files first
   - Example message: "ステージングされたファイルがありません。以下のコマンドでファイルをステージングしてください: `git add <filename>`"
   - Only proceed if staged changes exist

### Step 3: Enhanced Diff Analysis (CRITICAL - MANDATORY VALIDATION)

**🚨 ABSOLUTE REQUIREMENT: MUST EXECUTE `git diff --cached` BEFORE ANY COMMIT OPERATION**

**🚨 COGNITIVE BIAS PREVENTION: MUST ANALYZE ACTUAL DIFF CONTENT, NOT ASSUMPTIONS**

1. **Mandatory Diff Verification (絶対必須)**

   ```bash
   git status        # First: Check overall repository state
   git diff --cached | cat  # Second: MUST review staged changes
   ```

2. **Enhanced Critical Pre-Commit Validation Checklist**

   - ✅ **MUST execute `git diff --cached` and analyze output**
   - ✅ **MUST verify that commit message matches ONLY staged files**
   - ✅ **MUST NOT include unstaged files in commit message**
   - ✅ **MUST respect user's intentional staging decisions**
   - ✅ **MUST generate commit message based ONLY on staged diff content**
   - ✅ **MUST NOT rely on previous error messages or assumptions**
   - ✅ **MUST analyze actual diff content line-by-line**
   - ✅ **MUST identify the primary purpose of changes (feat/fix/refactor/etc.)**

3. **Cognitive Bias Prevention Rules (NEW)**

   - **🚨 NEVER assume change type based on previous context**
   - **🚨 NEVER use error messages as primary change classification**
   - **🚨 MUST read and analyze every line of the actual diff**
   - **🚨 MUST identify the main functional change, not side effects**
   - **🚨 MUST distinguish between primary functionality and technical fixes**
   - **🚨 MUST ask for clarification if diff analysis is unclear**
   - **🚨 MUST focus on WHAT the code does, not WHY it was changed**
   - **🚨 MUST ignore linter error messages when determining change type**
   - **🚨 MUST analyze code additions/deletions objectively**

4. **Enhanced Staging Verification Rules**

   - **Never assume**: Always verify what is actually staged
   - **User Intent**: Respect user's explicit staging choices
   - **Accuracy**: Commit message must reflect ONLY staged changes
   - **Verification**: If unsure, ask user to confirm staging intent
   - **Content Analysis**: Focus on what the code actually does, not what it fixes

5. **Enhanced Diff Analysis Process**

   - **Complete diff retrieval**: Full `git diff --cached` output
   - **File-by-file analysis**: Review each staged file change
   - **Line-by-line analysis**: Examine every addition and deletion
   - **Change type identification**: Categorize modifications based on actual content
   - **Primary purpose identification**: Determine the main goal of the changes
   - **Message alignment**: Ensure commit message describes actual staged changes
   - **Bias elimination**: Ignore previous context when analyzing current diff

6. **Enhanced Error Prevention**

   - **Mismatch Detection**: Flag if commit message doesn't match staged content
   - **Missing Files**: Never reference unstaged files in commit message
   - **User Communication**: Clearly explain what will be committed
   - **Assumption Prevention**: Never assume change type without diff analysis
   - **Context Isolation**: Analyze current diff independently of previous errors

7. **Handle new files**
   - For new files: Read file content directly
   - Explain that file content equals diff for new files

**VIOLATION CONSEQUENCES**:

- If this step is skipped or executed incorrectly, it results in:
  - ❌ Inaccurate commit messages
  - ❌ Unintended file inclusion/exclusion
  - ❌ Loss of user trust and workflow integrity
  - ❌ Violation of explicit user staging decisions
  - ❌ Misclassification of change types due to cognitive bias

### Step 4: Enhanced Commit Message Generation

1. **Analyze diff content (ENHANCED)**

   - **Primary Analysis**: Identify the main functional change
   - **Secondary Analysis**: Identify any technical improvements
   - **Change Classification**: Determine if it's feat, fix, refactor, etc.
   - **Scope Determination**: Identify affected components if applicable
   - **Description Extraction**: Extract key changes for description

2. **Generate Conventional Commit message**

   ```
   <type>[optional scope]: <description>

   [optional body]

   [optional footer(s)]
   ```

3. **Enhanced Validation**
   - **Ensure English language ONLY** - Never use Japanese or other languages
   - **Verify Conventional Commits compliance**
   - **Check description clarity**
   - **Verify accuracy against actual diff content**
   - **Confirm change type matches actual modifications**

### Step 5: Commit Execution

1. **Present commit message to user**

   ```
   Generated commit message:
   [commit message]

   Execute commit? (Auto-executing...)
   ```

2. **Execute commit**
   ```bash
   git commit -m "[generated message]"
   ```

## Error Handling

### Diff Retrieval Issues

1. **Complete failure**: Request manual diff input
2. **New files**: Read file content directly with explanation

### Commit Failures

1. **Pre-commit hook failures**: Show lint errors and stop
2. **Merge conflicts**: Instruct user to resolve conflicts
3. **No changes**: Inform user and abort

### Cognitive Bias Prevention (NEW)

1. **Unclear diff analysis**: Ask user to clarify the purpose of changes
2. **Multiple change types**: Identify the primary change and mention secondary ones
3. **Ambiguous modifications**: Request user input on change classification

## Safety Measures

### Critical Workflow Execution Policy (最重要ポリシー)

**🚨 ZERO TOLERANCE FOR WORKFLOW VIOLATIONS**

1. **Mandatory Verification Sequence**

   ```bash
   # MUST ALWAYS execute in this exact order:
   git status                    # 1. Check repository state
   git diff --cached | cat       # 2. Review staged changes
   # 3. Generate commit message based ONLY on staged diff
   # 4. Execute commit
   ```

2. **Enhanced Forbidden Actions**

   - ❌ **NEVER commit without `git diff --cached` verification**
   - ❌ **NEVER generate commit messages without reviewing actual staged changes**
   - ❌ **NEVER assume what files are staged**
   - ❌ **NEVER include unstaged files in commit descriptions**
   - ❌ **NEVER override user's intentional staging decisions**
   - ❌ **NEVER classify changes based on previous error messages**
   - ❌ **NEVER assume change type without analyzing actual diff content**
   - ❌ **NEVER let linter errors influence functional change classification**
   - ❌ **NEVER conflate technical fixes with primary functionality**

3. **Enhanced Required Verification Points**
   - ✅ Staged files list matches commit message content
   - ✅ Unstaged files are explicitly excluded from commit message
   - ✅ User's staging intent is respected and preserved
   - ✅ Commit message accurately reflects actual changes being committed
   - ✅ Change type is based on actual diff content, not assumptions
   - ✅ Primary functionality change is correctly identified

### Staging Policy (最重要ルール)

- **絶対に `git add` を自動実行しない**
- ユーザーが明示的にステージングしたファイルのみ処理
- ステージングされていない場合は適切なメッセージでユーザーに促す
- ユーザーの意図しないファイルをコミットしないよう安全を確保

### User Confirmation

- Always show generated commit message before execution
- Present commit message for user review before execution
- Allow manual message editing if requested

### Rollback Capability

- Provide instructions for `git reset --soft HEAD^` if needed

### Enhanced Diff Verification Accountability

- **Every commit operation MUST be preceded by diff verification**
- **Commit messages MUST be generated from actual staged content**
- **No exceptions**: This rule applies to ALL commit operations
- **Accountability**: Any violation of this policy is a critical workflow failure
- **Cognitive Bias Prevention**: Analysis must be based on actual diff, not assumptions

## Commit Message Standards

### Types

- **feat**: New feature
- **fix**: Bug fix
- **docs**: Documentation changes
- **style**: Code formatting
- **refactor**: Code restructuring
- **perf**: Performance improvements
- **test**: Testing additions/fixes
- **chore**: Build/tool changes
- **ci**: CI configuration and scripts
- **build**: Build system and external dependencies

### Format Requirements

- **English language only (英語のみ)** - CRITICAL REQUIREMENT
  - All commit messages MUST be written in English
  - This ensures consistency and international compatibility
  - Even when user communicates in Japanese, commit messages are always English
  - Examples: "feat: add new feature" ✅, "feat: 新機能を追加" ❌
- Clear, concise descriptions
- Proper conventional commits structure
- Informative body for complex changes

## Workflow Customization

### Skip Confirmation Mode

If user adds "すぐに" or "immediately":

- Skip confirmation prompt
- Execute commit immediately after message generation

### Manual Message Mode

If user requests custom message:

- Generate suggested message
- Ask for user's preferred message
- Use user's message instead

## Example Workflows

### Successful Workflow

```
User: "コミットして"
→ Check git status
→ Verify staged changes exist
→ Analyze diff with git diff --cached
→ Generate: "feat: add new YouTube player controls"
→ Execute commit
```

### No Staging Available Workflow

```
User: "コミットして"
→ Check git status
→ No staged changes found
→ Response: "ステージングされたファイルがありません。以下のコマンドでファイルをステージングしてください: `git add <filename>`"
→ Do NOT execute git add automatically
```

### Lint Error Workflow

```
User: "コミットしたい"
→ Pre-commit hook fails
→ Show lint errors
→ Response: "Please fix lint errors before committing"
```

### Enhanced Critical Verification Workflow (UPDATED)

```
User: "コミット"
→ git status (check repository state)
→ git diff --cached | cat (MANDATORY - review staged changes)
→ Analyze actual diff content line-by-line
→ Identify primary functional change (not technical fixes)
→ Generate accurate commit message based on actual changes
→ Execute commit
```

### Cognitive Bias Prevention Example (NEW)

```
Previous Error: "Invalid assignment to inputRef.current?.value"
Current Diff: Shows URL parsing and form input update functionality

❌ INCORRECT Analysis Process:
1. See previous error message about optional chaining
2. Assume change is fixing TypeScript error
3. Generate: "fix: resolve TypeScript error with optional chaining"

✅ CORRECT Analysis Process:
1. Ignore previous error message completely
2. Read actual diff line-by-line:
   - if (parsed && inputRef.current) { // null check added
   - inputRef.current.value = parsed.id; // form field updated
3. Identify primary functionality: URL parsing → form input update
4. Generate: "feat: extract YouTube ID from URL and update form input"
```

### Additional Bias Prevention Examples (NEW)

```
Scenario 1: Performance optimization with bug fix side effect
❌ Wrong: "fix: resolve memory leak"
✅ Right: "perf: optimize component rendering"

Scenario 2: Refactoring that happens to fix linter warnings
❌ Wrong: "fix: resolve linter warnings"
✅ Right: "refactor: extract utility functions"

Scenario 3: New feature that requires TypeScript type updates
❌ Wrong: "fix: update TypeScript types"
✅ Right: "feat: add video thumbnail preview"
```

This enhanced automated workflow ensures consistent, high-quality commits while maintaining strict verification standards, respecting user intent, and preventing cognitive bias in change analysis.
